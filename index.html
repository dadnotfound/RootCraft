import React, { useState, useEffect, useCallback, useMemo } from 'react';
import { Sparkles, BookOpen, AlertCircle, Check, X, RotateCcw, Trophy, Brain, Loader2, Wand2, Lightbulb, Upload } from 'lucide-react';

// --- 初始游戏数据 (模拟数据库) ---
const INITIAL_WORD_DATABASE = [
  { prefix: 're', root: 'act', suffix: 'ion', full: 'reaction', meaning: '反应', desc: 're(反) + act(行动) + ion(名词) = 反向的行动' },
  { prefix: 'inter', root: 'act', suffix: 'ive', full: 'interactive', meaning: '互动的', desc: 'inter(相互) + act(行动) + ive(形容词) = 相互行动的' },
  { prefix: 'con', root: 'struct', suffix: 'ion', full: 'construction', meaning: '建造/建筑物', desc: 'con(共同) + struct(建立) + ion(名词)' },
  { prefix: 'de', root: 'struct', suffix: 'ive', full: 'destructive', meaning: '破坏性的', desc: 'de(向下/去除) + struct(建立) + ive(形容词)' },
  { prefix: 'im', root: 'port', suffix: 'ant', full: 'important', meaning: '重要的', desc: 'im(进入) + port(运送/承载) + ant(形容词) = 承载着份量的' },
  { prefix: 'trans', root: 'port', suffix: '', full: 'transport', meaning: '运输', desc: 'trans(跨越) + port(运送) = 跨越运送' },
  { prefix: '', root: 'act', suffix: 'or', full: 'actor', meaning: '演员', desc: 'act(表演) + or(人)' },
  { prefix: 'pre', root: 'dict', suffix: 'ion', full: 'prediction', meaning: '预言', desc: 'pre(预先) + dict(说) + ion(名词)' },
  { prefix: '', root: 'vis', suffix: 'ible', full: 'visible', meaning: '可见的', desc: 'vis(看) + ible(能...的)' },
  { prefix: 'in', root: 'vis', suffix: 'ible', full: 'invisible', meaning: '看不见的', desc: 'in(不) + vis(看) + ible(能...的)' },
  { prefix: 'ex', root: 'port', suffix: '', full: 'export', meaning: '出口', desc: 'ex(向外) + port(运送)' },
  { prefix: 're', root: 'form', suffix: '', full: 'reform', meaning: '改革', desc: 're(再次) + form(形式) = 重塑形式' },
  { prefix: 'un', root: 'do', suffix: '', full: 'undo', meaning: '撤销', desc: 'un(不) + do(做) = 不做/撤销' },
  { prefix: 'over', root: 'look', suffix: '', full: 'overlook', meaning: '俯瞰/忽视', desc: 'over(在...上) + look(看) = 看漏了' },
  { prefix: '', root: 'look', suffix: 'er', full: 'looker', meaning: '旁观者', desc: 'look(看) + er(人)' },
  { prefix: 'sub', root: 'merge', suffix: '', full: 'submerge', meaning: '淹没', desc: 'sub(下) + merge(沉)' },
  { prefix: 'e', root: 'ject', suffix: 'ion', full: 'ejection', meaning: '喷射/排出', desc: 'e(出) + ject(扔) + ion(名词)' },
];

// --- Gemini API Helper ---
const apiKey = ""; // 系统会自动注入 API Key

const callGemini = async (prompt) => {
  let result = "魔法干扰...请重试";
  for (let i = 0; i < 3; i++) {
    try {
      const response = await fetch(
        `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`,
        {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            contents: [{ parts: [{ text: prompt }] }],
          }),
        }
      );
      const data = await response.json();
      result = data.candidates?.[0]?.content?.parts?.[0]?.text || result;
      break; // Success
    } catch (error) {
      console.error(`Gemini API Error (Attempt ${i + 1}):`, error);
      // 实现简单的指数退避
      await new Promise(res => setTimeout(res, 1000 * Math.pow(2, i)));
      if (i === 2) result = "连接魔法网络失败...";
    }
  }
  return result;
};

// --- 组件部分 (PixelCard 和 Button 保持不变) ---

const PixelCard = ({ type, text, isSelected, onClick, isDisabled = false }) => {
  let bgColor = "bg-white";
  let textColor = "text-gray-800";
  let label = "";

  if (type === 'prefix') {
    bgColor = isSelected ? "bg-blue-200" : "bg-blue-50";
    textColor = "text-blue-900";
    label = "前缀";
  } else if (type === 'root') {
    bgColor = isSelected ? "bg-amber-200" : "bg-amber-50";
    textColor = "text-amber-900";
    label = "词根";
  } else if (type === 'suffix') {
    bgColor = isSelected ? "bg-emerald-200" : "bg-emerald-50";
    textColor = "text-emerald-900";
    label = "后缀";
  }

  return (
    <button
      onClick={onClick}
      disabled={isDisabled}
      className={`
        relative group transition-all duration-100 ease-in-out
        w-24 h-32 m-2 flex flex-col items-center justify-center
        border-4 border-gray-900 
        ${isSelected ? 'translate-y-1 shadow-none' : 'shadow-[6px_6px_0px_0px_rgba(17,24,39,1)] hover:-translate-y-1 hover:shadow-[8px_8px_0px_0px_rgba(17,24,39,1)]'}
        ${bgColor}
        ${isDisabled ? 'opacity-50 cursor-not-allowed' : 'cursor-pointer'}
      `}
    >
      <span className="absolute top-1 left-1 text-[10px] uppercase font-bold text-gray-500 tracking-wider">{label}</span>
      <span className={`text-xl font-black font-mono tracking-tighter ${textColor}`}>{text}</span>
      {/* 像素角装饰 */}
      <div className="absolute top-0 right-0 w-2 h-2 bg-gray-900 opacity-20"></div>
      <div className="absolute bottom-0 left-0 w-2 h-2 bg-gray-900 opacity-20"></div>
    </button>
  );
};

const Button = ({ children, onClick, color = "primary", className = "", disabled = false }) => {
  const baseStyle = "px-6 py-3 font-bold font-mono border-4 border-gray-900 text-sm uppercase tracking-widest transition-all active:translate-y-1 active:shadow-none shadow-[4px_4px_0px_0px_rgba(0,0,0,1)] flex items-center justify-center gap-2";
  
  const colors = {
    primary: "bg-indigo-500 text-white hover:bg-indigo-400 disabled:bg-indigo-300",
    success: "bg-green-500 text-white hover:bg-green-400 disabled:bg-green-300",
    danger: "bg-red-500 text-white hover:bg-red-400 disabled:bg-red-300",
    neutral: "bg-gray-200 text-gray-900 hover:bg-gray-100 disabled:bg-gray-100",
    magic: "bg-purple-500 text-white hover:bg-purple-400 disabled:bg-purple-300",
    upload: "bg-gray-700 text-white hover:bg-gray-600 disabled:bg-gray-500"
  };

  return (
    <button onClick={onClick} disabled={disabled} className={`${baseStyle} ${colors[color]} ${className}`}>
      {children}
    </button>
  );
};


export default function App() {
  // 核心数据库状态 (现在是可变的)
  const [wordDatabase, setWordDatabase] = useState(INITIAL_WORD_DATABASE); 
  
  // 游戏状态
  const [gameState, setGameState] = useState('playing'); // playing, quiz, success, error, upload
  const [score, setScore] = useState(0);
  const [collection, setCollection] = useState([]);
  
  // 牌库状态
  const [availablePrefixes, setAvailablePrefixes] = useState([]);
  const [availableRoots, setAvailableRoots] = useState([]);
  const [availableSuffixes, setAvailableSuffixes] = useState([]);

  // 玩家选择状态
  const [selectedPrefix, setSelectedPrefix] = useState(null);
  const [selectedRoot, setSelectedRoot] = useState(null);
  const [selectedSuffix, setSelectedSuffix] = useState(null);

  // 测验与验证状态
  const [currentCombination, setCurrentCombination] = useState(null);
  const [quizOptions, setQuizOptions] = useState([]);
  const [feedbackMsg, setFeedbackMsg] = useState("");

  // AI 状态
  const [aiLoading, setAiLoading] = useState(false);
  const [hintVisible, setHintVisible] = useState(false);
  const [hintText, setHintText] = useState("");
  const [mnemonicText, setMnemonicText] = useState("");

  // 收集卡牌列表可见性状态
  const [isDeckVisible, setIsDeckVisible] = useState(false);

  // 动态计算所有可用的部件列表 (使用 useMemo 优化性能)
  const ALL_PREFIXES = useMemo(() => Array.from(new Set(wordDatabase.map(w => w.prefix).filter(p => p))), [wordDatabase]);
  const ALL_ROOTS = useMemo(() => Array.from(new Set(wordDatabase.map(w => w.root).filter(r => r))), [wordDatabase]);
  const ALL_SUFFIXES = useMemo(() => Array.from(new Set(wordDatabase.map(w => w.suffix).filter(s => s))), [wordDatabase]);

  // 初始化游戏
  useEffect(() => {
    resetBoard();
  }, [wordDatabase]); // 依赖 wordDatabase, 数据库更新时重置牌堆

  /**
   * 优化后的重置函数：确保牌堆中至少有一个可组合的有效单词。
   */
  const resetBoard = useCallback(() => {
    if (wordDatabase.length === 0 || ALL_ROOTS.length === 0) {
        setFeedbackMsg("数据库中缺少词根或单词，请先上传新的单词列表。");
        setGameState('error');
        return;
    }

    // 1. 随机选择一个目标单词 (保证可组合性)
    const targetWord = wordDatabase[Math.floor(Math.random() * wordDatabase.length)];
    
    // 初始化牌堆，包含目标单词的部件
    let newPrefixes = targetWord.prefix ? [targetWord.prefix] : [];
    let newRoots = [targetWord.root]; // 词根是必须的
    let newSuffixes = targetWord.suffix ? [targetWord.suffix] : [];

    // 筛选出未被使用的、可用来填充的部件
    const availableP = ALL_PREFIXES.filter(p => p !== targetWord.prefix);
    const availableR = ALL_ROOTS.filter(r => r !== targetWord.root);
    const availableS = ALL_SUFFIXES.filter(s => s !== targetWord.suffix);

    // 2. 填充剩余卡牌到目标数量 (例如，每个牌堆最多 6 张牌)
    const DECK_SIZE = 6;
    const fillDeck = (currentDeck, availableParts, size) => {
        let pool = [...availableParts].sort(() => 0.5 - Math.random());
        // 填充到 DECK_SIZE 或 ALL_PARTS 的总数 (取最小值)
        const targetSize = Math.min(size, currentDeck.length + pool.length);
        while (currentDeck.length < targetSize) {
            currentDeck.push(pool.pop());
        }
        return currentDeck.sort(() => 0.5 - Math.random());
    };

    setAvailablePrefixes(fillDeck(newPrefixes, availableP, DECK_SIZE));
    setAvailableRoots(fillDeck(newRoots, availableR, DECK_SIZE));
    setAvailableSuffixes(fillDeck(newSuffixes, availableS, DECK_SIZE));
    
    // 清空选择和状态
    setSelectedPrefix(null);
    setSelectedRoot(null);
    setSelectedSuffix(null);
    if (gameState !== 'error') {
        setGameState('playing');
        setFeedbackMsg("");
    }
    setHintVisible(false);
    setHintText("");
    setMnemonicText("");
  }, [wordDatabase, ALL_PREFIXES, ALL_ROOTS, ALL_SUFFIXES, gameState]);

  // --- 游戏逻辑 (保持不变) ---

  const handleCardClick = (type, text) => {
    if (gameState !== 'playing') return;

    if (type === 'prefix') {
      setSelectedPrefix(selectedPrefix === text ? null : text);
    } else if (type === 'root') {
      setSelectedRoot(selectedRoot === text ? null : text);
    } else if (type === 'suffix') {
      setSelectedSuffix(selectedSuffix === text ? null : text);
    }
  };

  const handleCombine = () => {
    if (!selectedRoot) {
      setFeedbackMsg("必须选择一个【词根】才能组合！");
      setGameState('error');
      return;
    }

    if (!selectedPrefix && !selectedSuffix) {
      setFeedbackMsg("必须至少选择一个前缀或后缀！");
      setGameState('error');
      return;
    }

    const p = selectedPrefix || '';
    const r = selectedRoot;
    const s = selectedSuffix || '';
    const attemptWord = `${p}${r}${s}`;

    const foundWord = wordDatabase.find(w => 
      (w.prefix === p || (!w.prefix && !p)) &&
      w.root === r &&
      (w.suffix === s || (!w.suffix && !s))
    );

    if (foundWord) {
      setCurrentCombination(foundWord);
      generateQuiz(foundWord);
      setGameState('quiz');
    } else {
      setFeedbackMsg(`"${attemptWord}" 不是我们收录的有效单词。`);
      setGameState('error');
    }
  };

  const generateQuiz = (correctWord) => {
    const otherMeanings = wordDatabase
      .filter(w => w.full !== correctWord.full)
      .map(w => w.meaning)
      .sort(() => 0.5 - Math.random())
      .slice(0, 3);
    
    const options = [...otherMeanings, correctWord.meaning].sort(() => 0.5 - Math.random());
    setQuizOptions(options);
  };

  const handleQuizAnswer = (answer) => {
    if (answer === currentCombination.meaning) {
      setScore(s => s + 100);
      setCollection(prev => [currentCombination, ...prev]);
      setGameState('success');
      setMnemonicText(""); // Reset mnemonic for new word
    } else {
      setScore(s => Math.max(0, s - 50));
      setFeedbackMsg(`回答错误！"${currentCombination.full}" 的意思是 "${currentCombination.meaning}"。`);
      setGameState('error');
    }
  };

  const refillCards = () => {
    // 成功后调用 resetBoard 重新生成牌堆
    resetBoard();
  };

  const closeOverlay = () => {
    if (gameState === 'success') {
        refillCards(); // 成功后调用卡牌刷新
    }
    setGameState('playing');
    setFeedbackMsg("");
    setHintVisible(false); // 重置 AI 提示状态
    setHintText("");
    setMnemonicText(""); // 重置 AI 助记状态
  };

  // --- 文件上传功能实现 (保持不变) ---

  const parseCSV = (csvText) => {
    const rows = csvText.trim().split('\n').filter(line => line.trim() !== '');
    if (rows.length < 2) return [];

    const dataRows = rows.slice(1); 

    return dataRows.map(row => {
        const parts = row.split(',').map(p => p.trim());
        if (parts.length < 6) {
            console.warn("Skipping row due to insufficient data:", row);
            return null;
        }

        return {
            prefix: parts[0] || '',
            root: parts[1],
            suffix: parts[2] || '',
            full: parts[3],
            meaning: parts[4],
            desc: parts[5],
        };
    }).filter(item => item !== null && item.root && item.full && item.meaning);
  };

  const handleFileUpload = (event) => {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const csvText = e.target.result;
        const newDatabase = parseCSV(csvText);
        
        if (newDatabase.length > 0) {
          setWordDatabase(newDatabase);
          setCollection([]);
          setScore(0);
          closeOverlay();
          setFeedbackMsg(`成功导入 ${newDatabase.length} 个单词，牌堆已重置!`);
          setGameState('success');
        } else {
          setFeedbackMsg("文件内容无效或格式不正确。请确保文件至少包含一行头部和一行数据，并以逗号分隔。");
          setGameState('error');
        }
      } catch (error) {
        console.error("File processing error:", error);
        setFeedbackMsg("处理文件时发生错误。请检查文件是否为纯文本 CSV 格式。");
        setGameState('error');
      }
    };
    reader.onerror = () => {
        setFeedbackMsg("无法读取文件。");
        setGameState('error');
    };
    reader.readAsText(file);
    // 重置 input value，以便用户再次上传相同文件
    event.target.value = null; 
  };

  // --- AI 功能实现 (已优化，确保提示基于当前牌堆) ---

  const handleGetHint = async () => {
    if (hintVisible) {
        setHintVisible(false);
        return;
    }
    setAiLoading(true);
    setHintVisible(true);

    // 1. 找出当前牌堆中所有可以组成的有效单词 (Grounded Hinting)
    const possibleWords = wordDatabase.filter(w => {
        const hasPrefix = !w.prefix || availablePrefixes.includes(w.prefix);
        const hasRoot = availableRoots.includes(w.root);
        const hasSuffix = !w.suffix || availableSuffixes.includes(w.suffix);
        // 必须包含词根，且如果它有前缀/后缀，那这些部件必须在当前牌堆中
        return hasRoot && hasPrefix && hasSuffix;
    });

    if (possibleWords.length === 0) {
        setHintText("Oracle 叹了口气... 牌桌上的部件太多不合群，无法组成任何有效单词。");
        setAiLoading(false);
        return;
    }
    
    // 2. 随机选择一个可组合的单词作为提示目标
    const targetHintWord = possibleWords[Math.floor(Math.random() * possibleWords.length)];

    const prompt = `
      我正在玩一个单词拼写游戏。我希望你针对一个目标单词提供一个谜语或提示。
      目标单词: "${targetHintWord.full}"
      中文含义: "${targetHintWord.meaning}"
      构词解析: "${targetHintWord.desc}"

      请根据上述信息，直接用中文给我一个关于这个单词的【幽默谜语】或【提示】，**不要直接包含这个单词的拼写，也不要说“这个单词是”**。
      让玩家猜猜看。限制在40字以内。
      你的回答格式必须是：[你的提示内容]
    `;

    const result = await callGemini(prompt);
    setHintText(result);
    setAiLoading(false);
  };

  const handleGenerateMnemonic = async () => {
    if (!currentCombination) return;
    setAiLoading(true);
    
    const prompt = `
      请为英文单词 "${currentCombination.full}" (中文含义: ${currentCombination.meaning}) 创作一个简短、幽默、令人印象深刻的中文助记句。
      可以用谐音梗，或者编一个小场景。
      格式要求：只返回助记句内容，不要废话。限制在60字以内。
    `;

    const result = await callGemini(prompt);
    setMnemonicText(result);
    setAiLoading(false);
  };

  // --- 渲染部分 (保持不变) ---

  return (
    <div className="min-h-screen bg-stone-200 font-sans text-gray-800 flex flex-col items-center p-4 selection:bg-indigo-200">
      
      {/* --- 顶部 UI --- */}
      <header className="w-full max-w-5xl flex justify-between items-center mb-6 bg-gray-900 text-white p-4 rounded-lg shadow-[6px_6px_0px_0px_rgba(0,0,0,0.2)] border-4 border-gray-900">
        <div className="flex items-center gap-3">
          <div className="p-2 bg-indigo-500 border-2 border-white rounded">
            <Brain size={24} />
          </div>
          <div>
            <h1 className="text-2xl font-black font-mono tracking-tighter uppercase">Word Alchemist</h1>
            <p className="text-xs text-gray-400 font-mono">像素单词构筑 + AI 赋能</p>
          </div>
        </div>

        <div className="flex gap-6 font-mono text-xl">
          <div className="flex flex-col items-end">
            <span className="text-xs text-gray-400 uppercase">Score</span>
            <span className="text-yellow-400 font-bold">{score.toString().padStart(6, '0')}</span>
          </div>
          {/* 已收集卡牌按钮 */}
          <button 
                onClick={() => setIsDeckVisible(prev => !prev)} 
                className="flex flex-col items-end p-1 hover:bg-gray-700 rounded transition-colors"
            >
                <span className="text-xs text-gray-400 uppercase">Cards (点击查看)</span>
                <span className="text-green-400 font-bold">{collection.length}</span>
          </button>
        </div>
      </header>

      {/* --- 游戏主区域 --- */}
      <main className="w-full max-w-5xl flex-1 flex gap-4 relative">
        
        {/* 左侧：前缀牌堆 */}
        <div className="flex-1 flex flex-col bg-[#e0e7ff] border-4 border-blue-900 rounded-xl p-4 shadow-inner relative overflow-hidden">
          <h2 className="text-center font-black text-blue-900 mb-4 bg-white border-2 border-blue-900 inline-block px-4 py-1 self-center shadow-[3px_3px_0px_0px_rgba(30,58,138,1)]">PREFIX</h2>
          <div className="flex flex-wrap justify-center content-start overflow-y-auto h-[500px] scrollbar-hide pb-20">
            {availablePrefixes.map((p, idx) => (
              <PixelCard 
                key={`p-${idx}`} 
                type="prefix" 
                text={p} 
                isSelected={selectedPrefix === p} 
                onClick={() => handleCardClick('prefix', p)}
                isDisabled={gameState !== 'playing'}
              />
            ))}
            {availablePrefixes.length === 0 && <p className="mt-8 text-gray-400">没有可用卡牌...</p>}
          </div>
          <div className="absolute bottom-0 left-0 w-full h-12 bg-gradient-to-t from-blue-100 to-transparent pointer-events-none"></div>
        </div>

        {/* 中间：词根牌堆 (必须选) */}
        <div className="flex-1 flex flex-col bg-[#fffbeb] border-4 border-amber-900 rounded-xl p-4 shadow-inner relative overflow-hidden z-10 scale-105">
           <div className="absolute top-0 left-0 w-full h-2 bg-amber-900/10"></div>
          <h2 className="text-center font-black text-amber-900 mb-4 bg-white border-2 border-amber-900 inline-block px-4 py-1 self-center shadow-[3px_3px_0px_0px_rgba(120,53,15,1)] flex items-center gap-2">
            <Sparkles size={16} /> ROOT <Sparkles size={16} />
          </h2>
          <div className="flex flex-wrap justify-center content-start overflow-y-auto h-[500px] scrollbar-hide pb-20">
            {availableRoots.map((r, idx) => (
              <PixelCard 
                key={`r-${idx}`} 
                type="root" 
                text={r} 
                isSelected={selectedRoot === r} 
                onClick={() => handleCardClick('root', r)}
                isDisabled={gameState !== 'playing'}
              />
            ))}
             {availableRoots.length === 0 && <p className="mt-8 text-gray-400">没有可用卡牌...</p>}
          </div>
          <div className="absolute bottom-0 left-0 w-full h-12 bg-gradient-to-t from-amber-100 to-transparent pointer-events-none"></div>
        </div>

        {/* 右侧：后缀牌堆 */}
        <div className="flex-1 flex flex-col bg-[#d1fae5] border-4 border-emerald-900 rounded-xl p-4 shadow-inner relative overflow-hidden">
          <h2 className="text-center font-black text-emerald-900 mb-4 bg-white border-2 border-emerald-900 inline-block px-4 py-1 self-center shadow-[3px_3px_0px_0px_rgba(6,78,59,1)]">SUFFIX</h2>
          <div className="flex flex-wrap justify-center content-start overflow-y-auto h-[500px] scrollbar-hide pb-20">
            {availableSuffixes.map((s, idx) => (
              <PixelCard 
                key={`s-${idx}`} 
                type="suffix" 
                text={s} 
                isSelected={selectedSuffix === s} 
                onClick={() => handleCardClick('suffix', s)}
                isDisabled={gameState !== 'playing'}
              />
            ))}
             {availableSuffixes.length === 0 && <p className="mt-8 text-gray-400">没有可用卡牌...</p>}
          </div>
          <div className="absolute bottom-0 left-0 w-full h-12 bg-gradient-to-t from-emerald-100 to-transparent pointer-events-none"></div>
        </div>

      </main>

      {/* --- 底部控制栏 --- */}
      <footer className="fixed bottom-6 z-40 bg-white border-4 border-gray-900 p-4 rounded-xl shadow-[8px_8px_0px_0px_rgba(0,0,0,1)] flex items-center gap-4 max-w-5xl w-full justify-center">
        
        {/* 上传按钮 */}
        <Button onClick={() => setGameState('upload')} color="upload" className="px-4">
             <Upload size={20} /> <span className="hidden sm:inline">Upload Data</span>
        </Button>

        <div className="flex items-center gap-2">
          {/* 预览槽 */}
          <div className={`w-20 h-12 flex items-center justify-center border-2 border-dashed border-gray-400 rounded bg-gray-50 font-mono font-bold ${selectedPrefix ? 'bg-blue-100 text-blue-800 border-blue-500 border-solid' : 'text-gray-300'}`}>
            {selectedPrefix || "PRE"}
          </div>
          <span className="text-gray-400 font-black">+</span>
          <div className={`w-20 h-12 flex items-center justify-center border-2 border-dashed border-gray-400 rounded bg-gray-50 font-mono font-bold ${selectedRoot ? 'bg-amber-100 text-amber-800 border-amber-500 border-solid' : 'text-gray-300'}`}>
            {selectedRoot || "ROOT"}
          </div>
          <span className="text-gray-400 font-black">+</span>
          <div className={`w-20 h-12 flex items-center justify-center border-2 border-dashed border-gray-400 rounded bg-gray-50 font-mono font-bold ${selectedSuffix ? 'bg-emerald-100 text-emerald-800 border-emerald-500 border-solid' : 'text-gray-300'}`}>
            {selectedSuffix || "SUF"}
          </div>
        </div>

        <div className="h-10 w-1 bg-gray-200 mx-2"></div>

        <Button onClick={handleCombine} color="primary" className="text-lg px-8" disabled={gameState !== 'playing' || availableRoots.length === 0}>
          COMBINE!
        </Button>
        <button onClick={resetBoard} className="p-3 text-gray-400 hover:text-gray-900 transition-colors border-2 border-transparent hover:border-gray-200 rounded">
            <RotateCcw size={20} />
        </button>

        {/* AI Hint Button */}
        <div className="relative">
            <Button 
                onClick={handleGetHint} 
                color="magic" 
                className="px-4"
                disabled={aiLoading || gameState !== 'playing' || availableRoots.length === 0}
            >
                {aiLoading && hintVisible ? <Loader2 className="animate-spin" size={20}/> : <Wand2 size={20} />}
                <span className="hidden sm:inline">Ask Oracle</span>
            </Button>
            
            {/* AI Hint Popup */}
            {hintVisible && (
                <div className="absolute bottom-full left-1/2 -translate-x-1/2 mb-4 w-64 bg-indigo-900 text-white p-4 rounded-lg shadow-xl border-2 border-purple-400 animate-in slide-in-from-bottom-2 z-50">
                    <div className="flex items-start gap-2">
                        <Sparkles className="text-purple-300 shrink-0 mt-1" size={16} />
                        <div className="text-sm font-mono">
                            {aiLoading ? "正在凝视水晶球..." : (hintText || "水晶球似乎有点模糊...")}
                        </div>
                    </div>
                    {/* 小三角 */}
                    <div className="absolute top-full left-1/2 -translate-x-1/2 -mt-2 border-8 border-transparent border-t-indigo-900"></div>
                </div>
            )}
        </div>
      </footer>

      {/* --- 弹窗层 --- */}
      
      {/* 1. 错误弹窗 */}
      {gameState === 'error' && (
        <div className="fixed inset-0 bg-black/60 z-50 flex items-center justify-center backdrop-blur-sm animate-in fade-in duration-200">
          <div className="bg-white border-4 border-gray-900 p-8 rounded-lg max-w-md w-full text-center shadow-[10px_10px_0px_0px_rgba(239,68,68,1)]">
            <div className="w-16 h-16 bg-red-100 text-red-600 rounded-full flex items-center justify-center mx-auto mb-4 border-4 border-red-600">
              <AlertCircle size={32} />
            </div>
            <h3 className="text-2xl font-black mb-2 uppercase text-red-600">Oops!</h3>
            <p className="text-gray-600 font-mono mb-6">{feedbackMsg}</p>
            <Button onClick={closeOverlay} color="danger">Try Again</Button>
          </div>
        </div>
      )}

      {/* 2. 测验弹窗 */}
      {gameState === 'quiz' && currentCombination && (
        <div className="fixed inset-0 bg-indigo-900/80 z-50 flex items-center justify-center backdrop-blur-sm animate-in zoom-in-95 duration-200">
          <div className="bg-white border-4 border-gray-900 p-8 rounded-xl max-w-lg w-full shadow-[12px_12px_0px_0px_rgba(0,0,0,1)] relative overflow-hidden">
            <div className="absolute top-0 left-0 w-full h-4 bg-indigo-500"></div>
            
            <div className="text-center mb-8">
              <span className="text-xs font-bold text-indigo-500 tracking-widest uppercase mb-2 block">New Word Discovered!</span>
              <h2 className="text-4xl font-black font-mono text-gray-900 mb-2">
                {currentCombination.full}
              </h2>
              <div className="flex justify-center gap-1 text-sm font-mono text-gray-500">
                <span className="text-blue-600">{currentCombination.prefix}</span>
                <span className="text-amber-600">{currentCombination.root}</span>
                <span className="text-emerald-600">{currentCombination.suffix}</span>
              </div>
            </div>

            <div className="grid grid-cols-1 gap-3">
              {quizOptions.map((option, idx) => (
                <button
                  key={idx}
                  onClick={() => handleQuizAnswer(option)}
                  className="p-4 text-left font-bold text-gray-700 bg-gray-100 hover:bg-indigo-100 hover:text-indigo-800 border-2 border-gray-300 hover:border-indigo-500 rounded transition-all active:scale-[0.98]"
                >
                  <span className="mr-3 font-mono text-gray-400">{['A','B','C','D'][idx]}.</span>
                  {option}
                </button>
              ))}
            </div>
          </div>
        </div>
      )}

      {/* 3. 成功/导入结果弹窗 */}
      {(gameState === 'success' || (gameState === 'error' && feedbackMsg.includes("成功导入"))) && currentCombination && (
        <div className="fixed inset-0 bg-yellow-500/80 z-50 flex items-center justify-center backdrop-blur-sm animate-in zoom-in-95 duration-300">
          <div className="bg-white border-4 border-gray-900 p-1 rounded-xl max-w-md w-full shadow-[16px_16px_0px_0px_rgba(0,0,0,1)] rotate-1">
            <div className="border-2 border-gray-900 rounded-lg p-6 bg-[url('https://www.transparenttextures.com/patterns/graphy.png')] bg-yellow-50 flex flex-col items-center text-center">
              
              <div className="w-full flex justify-between items-start mb-4">
                 <Trophy className="text-yellow-500 drop-shadow-sm" size={32} />
                 <span className="font-mono text-xs text-gray-400">{gameState === 'success' ? 'COLLECTED' : 'DATA IMPORTED'}</span>
              </div>
              
              {gameState === 'success' ? (
                <>
                    <h2 className="text-5xl font-black font-mono text-gray-900 mb-2 tracking-tighter">
                      {currentCombination.full}
                    </h2>
                    
                    <div className="bg-gray-900 text-white px-3 py-1 rounded font-bold text-lg mb-6 shadow-md -rotate-2">
                      {currentCombination.meaning}
                    </div>

                    <div className="w-full bg-white border-2 border-gray-200 p-4 rounded text-sm text-gray-600 font-mono mb-4 text-left">
                      <p className="mb-2 font-bold text-gray-800">构词解析：</p>
                      <p>{currentCombination.desc}</p>
                    </div>

                    {/* AI Mnemonic Section */}
                    <div className="w-full mb-6">
                      {!mnemonicText ? (
                          <button 
                              onClick={handleGenerateMnemonic}
                              disabled={aiLoading}
                              className="w-full py-3 border-2 border-dashed border-purple-400 bg-purple-50 text-purple-700 font-bold rounded hover:bg-purple-100 transition-colors flex items-center justify-center gap-2"
                          >
                              {aiLoading ? <Loader2 className="animate-spin" /> : <Lightbulb size={18} />}
                              {aiLoading ? "AI 正在创作..." : "✨ 生成 AI 魔法助记"}
                          </button>
                      ) : (
                          <div className="bg-purple-100 border-2 border-purple-300 p-3 rounded text-left relative">
                              <Sparkles className="absolute -top-2 -right-2 text-purple-500 fill-purple-500" size={20} />
                              <p className="text-xs text-purple-800 font-bold mb-1">AI 助记：</p>
                              <p className="text-purple-900 font-bold leading-relaxed">{mnemonicText}</p>
                          </div>
                      )}
                    </div>
                </>
              ) : (
                <div className="text-center">
                    <h2 className="text-2xl font-black font-mono text-gray-900 mb-4 tracking-tighter">
                      {feedbackMsg}
                    </h2>
                    <p className="text-sm text-gray-600 mb-4">新卡牌已装载！开始游戏吧。</p>
                </div>
              )}


              <Button onClick={closeOverlay} color="success" className="w-full">
                {gameState === 'success' ? 'Collect Card' : 'Start Playing'}
              </Button>
            </div>
          </div>
        </div>
      )}

      {/* 4. 文件上传弹窗 */}
      {gameState === 'upload' && (
        <div className="fixed inset-0 bg-black/60 z-50 flex items-center justify-center backdrop-blur-sm animate-in fade-in duration-200">
          <div className="bg-white border-4 border-gray-900 p-8 rounded-lg max-w-lg w-full text-center shadow-[10px_10px_0px_0px_rgba(20,83,45,1)]">
            <div className="w-16 h-16 bg-gray-100 text-gray-600 rounded-full flex items-center justify-center mx-auto mb-4 border-4 border-gray-600">
              <Upload size={32} />
            </div>
            <h3 className="text-2xl font-black mb-2 uppercase text-gray-900">Upload New Database</h3>
            <p className="text-gray-600 font-mono mb-4 text-sm">
              请上传一个 **CSV 或纯文本文件**来替换当前的单词数据库。
            </p>
            <div className="bg-gray-100 border-2 border-gray-300 p-4 rounded text-left mb-6 text-sm font-mono">
                <p className="font-bold text-gray-800 mb-2">文件格式要求:</p>
                <p>每行一个单词，以**逗号** `,` 分隔，包含以下 6 个字段:</p>
                <p className="text-green-700 font-bold mt-1">
                    Prefix, Root, Suffix, Full Word, Meaning, Description
                </p>
            </div>

            <label htmlFor="file-upload" className="block w-full cursor-pointer">
                <div className="py-3 px-6 bg-indigo-500 text-white font-bold rounded-lg border-2 border-indigo-700 hover:bg-indigo-600 transition-colors">
                    <span className="flex items-center justify-center gap-2"><Upload size={18} /> 选择 CSV 文件</span>
                </div>
                <input 
                    id="file-upload" 
                    type="file" 
                    accept=".csv, .txt" 
                    onChange={handleFileUpload} 
                    className="hidden" 
                />
            </label>
            <button onClick={closeOverlay} className="mt-4 text-gray-500 hover:text-gray-900 transition-colors font-mono text-sm">取消</button>
          </div>
        </div>
      )}

      {/* 收集列表展示 */}
      {isDeckVisible && collection.length > 0 && ( 
        <div className="fixed top-24 right-4 w-64 bg-white border-4 border-gray-900 rounded-lg p-3 shadow-2xl max-h-[calc(100vh-150px)] overflow-y-auto z-30 animate-in slide-in-from-right-10 duration-300">
           <h3 className="font-black text-center border-b-2 border-gray-100 pb-2 mb-2 flex items-center justify-center gap-2">
             <BookOpen size={16}/> 收集卡牌
           </h3>
           <div className="space-y-2">
             {collection.map((item, idx) => (
               <div key={idx} className="bg-gray-50 border border-gray-200 p-2 rounded text-xs">
                 <div className="font-bold">{item.full}</div>
                 <div className="text-gray-500">{item.meaning}</div>
               </div>
             ))}
           </div>
        </div>
      )}

      {/* CSS 补充 (隐藏滚动条等) */}
      <style>{`
        .scrollbar-hide::-webkit-scrollbar {
            display: none;
        }
        .scrollbar-hide {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
      `}</style>
    </div>
  );
}
